# GMP 调度器场景全过程分析

## 场景一

1. G1 创建 G2
    - P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用 go func() 创建 G2，为了局部性 G2 优先加入到 P1 的本地队列

## 场景二

1. G1 执行完毕
    - G1 运行完成后(函数：goexit)，M 上运行的 goroutine 切换为 G0，G0 负责调度时写成的切换(函数：schedule)。
    - 从 P 的本地队列取 G2，从 G0 切换到 G2，并开始运行 G2(函数: execute)。实现了线程 M1 的复用。

## 场景三、四、五

1. G2 开辟过多的 G
    - 导致 P1 本地队列满
2. G2 本地队列已经满了再创建 G7
    - P1 本地队列已满，对本地队列做 1/2 分割，将队列头部顺序打乱，将 G7 和打乱后的 G3 和 G4 放入全局队列，将队列尾部的 G5、G6 往前移
3. G2 本地队列未满创建 G8
    - P1 本地队列直接加入 G8

## 场景六

1. 唤醒正在休眠的 M
    - 每次创建 G 时，运行的 G 会尝试唤醒其他空闲的 P 和 M 组合去执行。
    - 假定 G2 唤醒了 M2，M2 绑定了 P2，并运行 G0，但 P2 本地队列没有 G，M2 此时为自旋线程(没有 G 但为运行状态的线程，不断寻找 G)。

## 场景七

1. 被唤醒的 M2 从全局队列取批量 G
    - M2 尝试从全局队列(简称 GQ)取一批 G 放到 P2 的本地队列(函数：findrunnable())。
    - M2 从全局队列取的 G 数量符合下面的公式：`n = min(len(GQ)/GOMAXPROCS+1, len(GQ/2))`

