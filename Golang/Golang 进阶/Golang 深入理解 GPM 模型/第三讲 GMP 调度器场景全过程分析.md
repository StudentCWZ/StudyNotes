# GMP 调度器场景全过程分析

## 场景一

1. G1 创建 G2
    - P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用 go func() 创建 G2，为了局部性 G2 优先加入到 P1 的本地队列

## 场景二

1. G1 执行完毕
    - G1 运行完成后(函数：goexit)，M 上运行的 goroutine 切换为 G0，G0 负责调度时写成的切换(函数：schedule)。
    - 从 P 的本地队列取 G2，从 G0 切换到 G2，并开始运行 G2(函数: execute)。实现了线程 M1 的复用。

## 场景三、四、五

1. G2 开辟过多的 G
    - 导致 P1 本地队列满
2. G2 本地队列已经满了再创建 G7
    - P1 本地队列已满，对本地队列做 1/2 分割，将队列头部顺序打乱，将 G7 和打乱后的 G3 和 G4 放入全局队列，将队列尾部的 G5、G6 往前移
3. G2 本地队列未满创建 G8
    - P1 本地队列直接加入 G8

## 场景六

1. 唤醒正在休眠的 M
    - 每次创建 G 时，运行的 G 会尝试唤醒其他空闲的 P 和 M 组合去执行。
    - 假定 G2 唤醒了 M2，M2 绑定了 P2，并运行 G0，但 P2 本地队列没有 G，M2 此时为自旋线程(没有 G 但为运行状态的线程，不断寻找 G)。

## 场景七

1. 被唤醒的 M2 从全局队列取批量 G
    - M2 尝试从全局队列(简称 GQ)取一批 G 放到 P2 的本地队列(函数：findrunnable())。
    - M2 从全局队列取的 G 数量符合下面的公式：`n = min(len(GQ)/GOMAXPROCS+1, len(GQ/2))`

## 场景八

1. 偷取 G 情况
    - 全局队列已经没有 G，那么 M2 就要执行 work stealing(偷取)：从其他有 G 的 P 那里偷取一半 G 过来，放到自己的 P 本地队列。P2 从 P1 的本地队列尾部取一半的 G，本例子中一半则只有 1 个 G8，放到 P2 的本地队列并执行

## 场景九

1. 自旋线程的最大限制
    - 自旋线程 + 执行线程 <= GOMAXPROCS
    - 最多有 GOMAXPROCS 个自旋的线程，多余的没事做的线程会让它们休眠

## 场景十

1. G 发生调用阻塞
    - 假定当前除了 M3 和 M4 为自旋线程，还有 M5 和 M6 为空闲的线程(没有得到 P 得绑定，注意我们这里最多就只能够存在 4 个 P，
      所以 P 的数量应该永远是 M >= P，大部分都是 M 抢占需要运行的 P)，G8 创建了 G9，G8 进行了阻塞的系统调用，M2 和 P2 立即解绑，P2 会执行以下判断：如果 P2 本地队列有 G、全局队列有 G 或有空闲的 M，P2 都会立马去唤醒 1 个 M和它绑定，否则 P2 则会加入到空闲 P 列表，等待 M 来获取可用的 IP。本场景中，P2 本地队列有 G9，可以和其他空闲的线程 M5 绑定

## 场景 十一

1. G 发生系统调用/非阻塞
    - M2 和 P2 会解绑，但 M2 会记住 P2，然后 G8 和 M2 进行系统调用状态，当 G8 和 M2 退出系统调用时，会尝试获取 P2，如果无法获取，则获取空闲的 P，如果依然没有，G8 会被记为可运行状态，并加入到全局队列，M2 因为没有 P 的绑定而变成休眠状态(长时间休眠等待 GC 回收销毁)
