# Golang 协程调度器场景分析 & GMP 设计思想
## Golang 调度器的由来
1. 单进程时代的两个问题
    + 单一执行流程、计算机只能一个任务一个任务处理
    + 进程阻塞所带来的 CPU 浪费时间
2. 多进程、多线程的问题？
    + 设计变得复杂
        * 进程/线程的**数量越多**，切换**成本就越大**，也就越浪费(CPU 100% ==> 60% 执行程序；40% 在切换中)
        * 多线程随着**同步竞争**(如锁、竞争资源冲突等)，开发设计变得**越来越复杂** 
    + 多线程、多进程的壁垒
        * 高内存占用
            - 进程占用内存：虚拟内存 **4** GB(32 bit OS)
            - 线程占用内存约 **4** MB
        * 高 CPU 调度消耗
3. 协程(co-routine)，引发的问题
    + N:1 关系
        * 无法利用多个 CPU
        * 出现阻塞的瓶颈
    + 1:1 关系
        * 跟多线程/多进程模型无异
        * 切换协程成本代价昂贵
    + M:N 关系
        * 能够利用多核
        * 过于依赖协程调度器的优化和算法
3. 调度器的优化
    + Goroutine 的优化
        * 内存占用
            - 几 KB
            - 大量开辟
        * 灵活调度
            - 切换成本低
    + 早期 Golang 的调度器
        * 基本的全局 Go 队列和比较传统的轮询利用多个 thread 去调度
        * 弊端：
            - 创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了**激烈的锁竞争**。
            - M 转移 G 会造成**延迟和额外的系统负载**。
            - 系统调用(CPU 在 M 之间的切换)导致频繁的线程阻塞和取消阻塞操作**增加了系统开销**。
