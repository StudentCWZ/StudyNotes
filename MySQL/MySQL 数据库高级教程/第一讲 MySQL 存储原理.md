# 第一讲 MySQL 存储原理

## 1 索引的概述

### 1.1 为什么要使用索引

1. 在海量数据中进行查询某条记录的场景是经常发生的，那么如何提升查询性能，就跟要查询的数据字段是否有索引有关系。如果字段加了索引，那么查询的性能就非常快！
   - **索引为什么快？**
   - **索引到底是什么？**
   - **在使用索引的时候要注意什么的事项？**

### 1.2 索引是什么

1. 查字典的方式？ ==> 通过目录来查，能够快速的定位到目标数据所在的页码。

2. 全表扫描方式 ==> 没有使用索引，进行多次磁盘 I/O，造成了较大的性能开销。(类比 ==> 逐页翻字典场景)
3. 为数据库某个字段创建索引，相当是为这个字段的内容建立了一个目录。通过这个目录，可以快速的实现数据的定位，也就是通过索引能够快速的找到某条数据所在磁盘位置。
4. 现在的疑问？
   - 索引存放位置
   - 索引的分类及如何分类
   - 索引使用了哪种数据结构：各种数据结构的查询性能进行分析

### 1.3 索引存放的位置

1. 对于 Mac 系统，在 `/usr/local/mysql` 文件夹中，对于 Win 系统 `C:/programdata/mysql(隐藏文件夹)`
   - **InnoDB 存储引擎的表: 将索引和数据存放在同一个文件里(为什么？有什么优势？)**
     - `索引+数据`: `*.ibd`
   - **MyISAM 存储引擎的表: 索引和数据分开两个文件来存储**
     - **索引**: `*.MYI`
     - **数据**: `*.MYD`

### 1.4 索引的分类

1. **主键索引: 主键自带索引效果，也就意味着通过主键来查询表中的记录，性能是非常好的。**

2. **普通索引: 为普通列创建的索引**

   - **创建普通索引命令**

     ```SQL
     # 格式
     create index 索引名称 on 表名(列名);
     # 例子
     create index idx_name on employees(name);
     ```

3. **唯一索引: 就像是唯一列，列中的数据是唯一的。比普通索引的性能要好**

   - **创建唯一索引**

     ```SQL
     # 格式
     create unique index 索引名称 on 表名(列名);
     # 例子
     create index idx_name on employees(name);
     ```

4. **联合索引(组合索引): 一次性为表中的多个字段一起创建索引。注意: 一个联合索引建议不要超过五个字段**

   - **创建联合索引**

     ```SQL
     # 格式
     create unique index 索引名称 on 表名(列 1, 列 2, 列 3);
     # 例子
     create index idx_name_age_position on employees(name, age, position);
     ```

5. **全文索引: MyISAM 存储引擎支持全文索引，在实际生产环境中，并不会使用 MySQL 提供的 MyISAM 存储引擎的全文索引功能来实现全文查找，而是会使用第三方的搜索引擎中间件，比如 ElastSearch、solr**

## 2 索引使用的数据结构

### 2.1 数据结构

1. 什么是数据结构：存放数据的结构。比如：数组、链表、栈、堆、队列等等。

### 2.2 线性表

1. 线性的维护数据的顺序

2. 对于线性表来说，有两种数据结构来支撑：

   - **线性顺序表: 相邻两个数据的逻辑关系和物理位置是相同的。**
   - **线性链式表: 相邻两个数据的逻辑关系和物理存放位置没有关系。数据是有先后的逻辑关系，但是数据的物理存储位置并不连续。**

3. 线性链式表

   - **单向链表: 能够通过当前节点找到下一个节点的位置，以此来维护链表的逻辑结构**
     - **节点结构: 数据内容+下一个数据的指针**
   - **双向链表: 能够通过当前节点找到上一个或下一个节点的位置，双向都可找**
     - **结点结构: 上一个数据的指针+数据内容+下一个数据的指针**

4. 顺序表和链式表的区别：

   - **评估指标: 时间复杂度(比较次数)/空间复杂度(算法需要多少个变量空间):**

   - **数组**
     - **数组的查询性能非常好: 时间复杂度是 O(1)**
     - **数组的增删性能非常差**
   - **链表**
     - **查询性能是非常差的: 时间复杂度 O(n)**
     - **增删性能是非常好的**

### 2.3 栈和队列

1. **栈: 先进后出(FILO)**
   - 顺序栈
   - 链栈
2. **队列: 先进先出(FIFO)**
   - 顺序队列
   - 链式队列

### 2.4 串 string

1. 定长串
2. 动态串

### 2.5 数组和广义表

1. 数组
   - 一维数组
   - 二维数组
2. **广义表: 更加灵活的多维数组，可以在不同的元素中创建不同的维度的数组**

### 2.6 树

1. 查找树的查找性能是明显比线性表性能要好的，那么接下来我们就要学习这几种树

### 2.6.1 多叉树

1. 非二叉树

### 2.6.2 二叉树

1. 二叉树: 一个节点最多只能有 2 个子节点，可以是 0、1、2 子节点

### 2.6.3 二叉查找树

1. **二叉查找树: 二叉查找树查找性能是 ok 的，查询性能和树的高度有关，树的高度又跟你插入数据的顺序有关系。特点：二叉树的根节点的数值是比所有左子树的节点数值大，比右子树的节点的数值都小。这样的规律同样满足于他的所有子树。**

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="二叉查找树" style="zoom:50%;" />

### 2.6.4 平衡二叉树(理想概念的树)

1. 平衡二叉树: 我们知道二叉查找树不能非常智能维护树的高度，因此二叉查找树在某些情况下查询性能不是 ok 的，此时平衡二叉树就出现了。

2. 平衡二叉树，又称为 AVL 树。实际上就是遵循以下两个特点的二叉树：

   - 每棵子树中的左子树和右子树的深度不能超过 1

   - 二叉树中每棵子树都要求是平衡二叉树

3. **其实就是在二叉树的基础上，若树中每棵子树都满足其左子树和右子树的深度都不超过 1，则这棵二叉树就是平衡二叉树**

4. 如果平衡二叉树不满足这个特点，那么平衡二叉树要进行自己旋转，如何自己旋转：

   - 左旋
   - 右旋
   - 双向
     - 先左后右
     - 先右后左

### 2.6.5 红黑树(平衡二叉树的一种体现)

1. 红黑树是一种特化的 AVL(平衡二叉树)，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。

2. 在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求

   - 性质一: 节点是红色或是黑色
   - 性质二: 根节点是黑色
   - 性质三: 不可能有连在一起的红色节点
   - 性质四: 每个红色节点的两个子节点都是黑色。叶子节点都是黑色的(nil-黑色的空节点)

3. 这些约束强制了红黑树的关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个数大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树

4. 红黑树结构

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树" style="zoom:50%;" />

5. 平衡二叉树为了维护树的平衡，在一旦不满足平衡的情况就要进行自旋，但是自旋会造成一定的系统开销。因此。红黑树在自旋造成的系统开销和减少查询次数之间做了权衡。因此，红黑树有时候并不是一棵平衡二叉树
6. 红黑树已经是在查询性能上得到优化，但索引依然没有使用红黑树数据结构来存储数据，因为红黑树在每一层上存放的数据内容是有限的，导致数据量一大，树的深度就变的非常大，于是查询性能非常差。因此索引没有使用红黑树。

### 2.6.6 B 树

1. B 树允许一个节点存放多个数据。这样可以使更小的树的深度来存放更多的数据。但是，B 树的一个节点中到底能存放多少个数据，决定了树的深度。

2. 通过数值计算，B 树的一个节点最多只能存放 15 个数据，因此 B 树依然不能满足海量数据的查询性能优化

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/B%20Tree.png" alt="B Tree"  />

### 2.6.7 B+ 树

1. B+ Tree 的特点:

   - **非叶子节点冗余了叶子节点中的数据**
   - **叶子节点是从小到大、从左到右排列**
   - **叶子节点之间提供了指针，提高了区间访问的性能**
   - **只有叶子节点存放键和值**，非叶子节点是不存放数据的，只存放键

2. B+ Tree 结构

   ![B Tree(变种)](https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/B%20Tree(%E5%8F%98%E7%A7%8D).png)

### 2.6.8 哈希表

1. 使用哈希表来存取数据的性能是最高，O(1)，但不支持范围查找(区间访问)

## 3 InnoDB 和 MyISAM 区别

1. InnoDB 和 MyISAM 都是数据库表的引擎。那么在互联网公司，或者追求查询性能场景下，都会使用 InnoDB 作为表的存储引擎。
2. InnoDB 把索引和数据存放在一个文件中，通过找到索引就能直接在索引树上的叶子节点中获得完整的数据。 ==> 聚集索引
3. InnoDB 可以实现行锁/表锁。
4. MyISAM 把索引和数据存放在两个文件中，查找到索引后，还需要去另一个文件中找数据，性能会慢一些。 ==> 非聚集索引
5. MyISAM 天然支持表锁，而且支持全文索引。
