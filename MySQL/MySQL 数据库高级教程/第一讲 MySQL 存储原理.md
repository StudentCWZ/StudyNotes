# 第一讲 MySQL 存储原理

## 1 索引的概述 

### 1.1 为什么要使用索引

1. 在海量数据中进行查询某条记录的场景是经常发生的，那么如何提升查询性能，就跟要查询的数据字段是否有索引有关系。如果字段加了索引，那么查询的性能就非常快！
   - **索引为什么快？**
   - **索引到底是什么？**
   - **在使用索引的时候要注意什么的事项？**

### 1.2 索引是什么

1. 查字典的方式？ ==> 通过目录来查，能够快速的定位到目标数据所在的页码。

2. 全表扫描方式 ==> 没有使用索引，进行多次磁盘 I/O，造成了较大的性能开销。(类比 ==> 逐页翻字典场景)
3. 为数据库某个字段创建索引，相当是为这个字段的内容建立了一个目录。通过这个目录，可以快速的实现数据的定位，也就是通过索引能够快速的找到某条数据所在磁盘位置。
4. 现在的疑问？
   - 索引存放位置
   - 索引的分类及如何分类
   - 索引使用了哪种数据结构：各种数据结构的查询性能进行分析

### 1.3 索引存放的位置

1. 对于 Mac 系统，在 `/usr/local/mysql` 文件夹中，对于 Win 系统 `C:/programdata/mysql(隐藏文件夹)`
   - **InnoDB 存储引擎的表: 将索引和数据存放在同一个文件里(为什么？有什么优势？)**
     - `索引+数据`: `*.ibd`
   - **MyISAM 存储引擎的表: 索引和数据分开两个文件来存储**
     - **索引**: `*.MYI`
     - **数据**: `*.MYD`

### 1.4 索引的分类

1. **主键索引: 主键自带索引效果，也就意味着通过主键来查询表中的记录，性能是非常好的。**

2. **普通索引: 为普通列创建的索引**

   - **创建普通索引命令**

     ```SQL
     # 格式
     create index 索引名称 on 表名(列名);
     # 例子
     create index idx_name on employees(name);
     ```

3. **唯一索引: 就像是唯一列，列中的数据是唯一的。比普通索引的性能要好**

   - **创建唯一索引**

     ```SQL
     # 格式
     create unique index 索引名称 on 表名(列名);
     # 例子
     create index idx_name on employees(name);
     ```

4. **联合索引(组合索引): 一次性为表中的多个字段一起创建索引。注意: 一个联合索引建议不要超过五个字段**

   - **创建联合索引**

     ```SQL
     # 格式
     create unique index 索引名称 on 表名(列 1, 列 2, 列 3);
     # 例子
     create index idx_name_age_position on employees(name, age, position);
     ```

5. **全文索引: MyISAM 存储引擎支持全文索引，在实际生产环境中，并不会使用 MySQL 提供的 MyISAM 存储引擎的全文索引功能来实现全文查找，而是会使用第三方的搜索引擎中间件，比如 ElastSearch、solr**

## 2 索引使用的数据结构

### 2.1 数据结构

1. 什么是数据结构：存放数据的结构。比如：数组、链表、栈、堆、队列等等。

### 2.2 线性表

1. 线性的维护数据的顺序

2. 对于线性表来说，有两种数据结构来支撑：

   - **线性顺序表: 相邻两个数据的逻辑关系和物理位置是相同的。**
   - **线性链式表: 相邻两个数据的逻辑关系和物理存放位置没有关系。数据是有先后的逻辑关系，但是数据的物理存储位置并不连续。**

3. 线性链式表

   - **单向链表: 能够通过当前节点找到下一个节点的位置，以此来维护链表的逻辑结构**
     - **节点结构: 数据内容+下一个数据的指针**
   - **双向链表: 能够通过当前节点找到上一个或下一个节点的位置，双向都可找**
     - **结点结构: 上一个数据的指针+数据内容+下一个数据的指针**

4. 顺序表和链式表的区别：

   - **评估指标: 时间复杂度(比较次数)/空间复杂度(算法需要多少个变量空间):**

   - **数组**
     - **数组的查询性能非常好: 时间复杂度是 O(1)**
     - **数组的增删性能非常差**
   - **链表**
     - **查询性能是非常差的: 时间复杂度 O(n)**
     - **增删性能是非常好的**

### 2.3 栈和队列

1. **栈: 先进后出(FILO)**
   - 顺序栈
   - 链栈
2. **队列: 先进先出(FIFO)**
   - 顺序队列
   - 链式队列

### 2.4 串 string

1. 定长串
2. 动态串

### 2.5 数组和广义表

1. 数组
   - 一维数组
   - 二维数组
2. **广义表: 更加灵活的多维数组，可以在不同的元素中创建不同的维度的数组**

### 2.6 树

1. 查找树的查找性能是明显比线性表性能要好的，那么接下来我们就要学习这几种树
   - 多叉树
   - 二叉树: 一个节点最多只能有 2 个子节点，可以是 0、1、2 子节点
   - 二叉查找树: 二叉查找树查找性能是 ok 的，特点：二叉树的根节点的数值是比所有左子树的节点数值大，比右子树的节点的数值都小。这样的规律同样满足于他的所有子树。
   - 平衡二叉树
   - 红黑树
   - B 树
   - B+树

