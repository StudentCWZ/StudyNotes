# 第一讲 MySQL 存储原理

## 1 索引的概述

### 1.1 为什么要使用索引

1. 在海量数据中进行查询某条记录的场景是经常发生的，那么如何提升查询性能，就跟要查询的数据字段是否有索引有关系。如果字段加了索引，那么查询的性能就非常快！
   - **索引为什么快？**
   - **索引到底是什么？**
   - **在使用索引的时候要注意什么的事项？**

### 1.2 索引是什么

1. 查字典的方式？ ==> 通过目录来查，能够快速的定位到目标数据所在的页码。

2. 全表扫描方式 ==> 没有使用索引，进行多次磁盘 I/O，造成了较大的性能开销。(类比 ==> 逐页翻字典场景)
3. 为数据库某个字段创建索引，相当是为这个字段的内容建立了一个目录。通过这个目录，可以快速的实现数据的定位，也就是通过索引能够快速的找到某条数据所在磁盘位置。
4. 现在的疑问？
   - 索引存放位置
   - 索引的分类及如何分类
   - 索引使用了哪种数据结构：各种数据结构的查询性能进行分析

### 1.3 索引存放的位置

1. 对于 Mac 系统，在 `/usr/local/mysql` 文件夹中，对于 Win 系统 `C:/programdata/mysql(隐藏文件夹)`
   - **InnoDB 存储引擎的表: 将索引和数据存放在同一个文件里(为什么？有什么优势？)**
     - `索引+数据`: `*.ibd`
   - **MyISAM 存储引擎的表: 索引和数据分开两个文件来存储**
     - **索引**: `*.MYI`
     - **数据**: `*.MYD`

### 1.4 索引的分类

1. **主键索引: 主键自带索引效果，也就意味着通过主键来查询表中的记录，性能是非常好的。**

2. **普通索引: 为普通列创建的索引**

   - **创建普通索引命令**

     ```SQL
     # 格式
     create index 索引名称 on 表名(列名);
     # 例子
     create index idx_name on employees(name);
     ```

3. **唯一索引: 就像是唯一列，列中的数据是唯一的。比普通索引的性能要好**

   - **创建唯一索引**

     ```SQL
     # 格式
     create unique index 索引名称 on 表名(列名);
     # 例子
     create index idx_name on employees(name);
     ```

4. **联合索引(组合索引): 一次性为表中的多个字段一起创建索引。注意: 一个联合索引建议不要超过五个字段**

   - **创建联合索引**

     ```SQL
     # 格式
     create unique index 索引名称 on 表名(列 1, 列 2, 列 3);
     # 例子
     create index idx_name_age_position on employees(name, age, position);
     ```

5. **全文索引: MyISAM 存储引擎支持全文索引，在实际生产环境中，并不会使用 MySQL 提供的 MyISAM 存储引擎的全文索引功能来实现全文查找，而是会使用第三方的搜索引擎中间件，比如 ElastSearch、solr**

## 2 索引使用的数据结构

### 2.1 数据结构

1. 什么是数据结构：存放数据的结构。比如：数组、链表、栈、堆、队列等等。

### 2.2 线性表

1. 线性的维护数据的顺序

2. 对于线性表来说，有两种数据结构来支撑：

   - **线性顺序表: 相邻两个数据的逻辑关系和物理位置是相同的。**
   - **线性链式表: 相邻两个数据的逻辑关系和物理存放位置没有关系。数据是有先后的逻辑关系，但是数据的物理存储位置并不连续。**

3. 线性链式表

   - **单向链表: 能够通过当前节点找到下一个节点的位置，以此来维护链表的逻辑结构**
     - **节点结构: 数据内容+下一个数据的指针**
   - **双向链表: 能够通过当前节点找到上一个或下一个节点的位置，双向都可找**
     - **结点结构: 上一个数据的指针+数据内容+下一个数据的指针**

4. 顺序表和链式表的区别：

   - **评估指标: 时间复杂度(比较次数)/空间复杂度(算法需要多少个变量空间):**

   - **数组**
     - **数组的查询性能非常好: 时间复杂度是 O(1)**
     - **数组的增删性能非常差**
   - **链表**
     - **查询性能是非常差的: 时间复杂度 O(n)**
     - **增删性能是非常好的**

### 2.3 栈和队列

1. **栈: 先进后出(FILO)**
   - 顺序栈
   - 链栈
2. **队列: 先进先出(FIFO)**
   - 顺序队列
   - 链式队列

### 2.4 串 string

1. 定长串
2. 动态串

### 2.5 数组和广义表

1. 数组
   - 一维数组
   - 二维数组
2. **广义表: 更加灵活的多维数组，可以在不同的元素中创建不同的维度的数组**

### 2.6 树

1. 查找树的查找性能是明显比线性表性能要好的，那么接下来我们就要学习这几种树

### 2.6.1 多叉树

1. 非二叉树

### 2.6.2 二叉树

1. 二叉树: 一个节点最多只能有 2 个子节点，可以是 0、1、2 子节点

### 2.6.3 二叉查找树

1. **二叉查找树: 二叉查找树查找性能是 ok 的，查询性能和树的高度有关，树的高度又跟你插入数据的顺序有关系。特点：二叉树的根节点的数值是比所有左子树的节点数值大，比右子树的节点的数值都小。这样的规律同样满足于他的所有子树。**

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="二叉查找树" style="zoom:50%;" />

### 2.6.4 平衡二叉树(理想概念的树)

1. 平衡二叉树: 我们知道二叉查找树不能非常智能维护树的高度，因此二叉查找树在某些情况下查询性能不是 ok 的，此时平衡二叉树就出现了。

2. 平衡二叉树，又称为 AVL 树。实际上就是遵循以下两个特点的二叉树：

   - 每棵子树中的左子树和右子树的深度不能超过 1

   - 二叉树中每棵子树都要求是平衡二叉树

3. **其实就是在二叉树的基础上，若树中每棵子树都满足其左子树和右子树的深度都不超过 1，则这棵二叉树就是平衡二叉树**

4. 如果平衡二叉树不满足这个特点，那么平衡二叉树要进行自己旋转，如何自己旋转：

   - 左旋
   - 右旋
   - 双向
     - 先左后右
     - 先右后左

### 2.6.5 红黑树(平衡二叉树的一种体现)

1. 红黑树是一种特化的 AVL(平衡二叉树)，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。

2. 在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求

   - 性质一: 节点是红色或是黑色
   - 性质二: 根节点是黑色
   - 性质三: 不可能有连在一起的红色节点
   - 性质四: 每个红色节点的两个子节点都是黑色。叶子节点都是黑色的(nil-黑色的空节点)

3. 这些约束强制了红黑树的关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个数大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树

4. 红黑树结构

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树" style="zoom:50%;" />

5. 平衡二叉树为了维护树的平衡，在一旦不满足平衡的情况就要进行自旋，但是自旋会造成一定的系统开销。因此。红黑树在自旋造成的系统开销和减少查询次数之间做了权衡。因此，红黑树有时候并不是一棵平衡二叉树
6. 红黑树已经是在查询性能上得到优化，但索引依然没有使用红黑树数据结构来存储数据，因为红黑树在每一层上存放的数据内容是有限的，导致数据量一大，树的深度就变的非常大，于是查询性能非常差。因此索引没有使用红黑树。

### 2.6.6 B 树

1. B 树允许一个节点存放多个数据。这样可以使更小的树的深度来存放更多的数据。但是，B 树的一个节点中到底能存放多少个数据，决定了树的深度。

2. 通过数值计算，B 树的一个节点最多只能存放 15 个数据，因此 B 树依然不能满足海量数据的查询性能优化

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/B%20Tree.png" alt="B Tree"  />

### 2.6.7 B+ 树

1. B+ Tree 的特点:

   - **非叶子节点冗余了叶子节点中的数据**
   - **叶子节点是从小到大、从左到右排列**
   - **叶子节点之间提供了指针，提高了区间访问的性能**
   - **只有叶子节点存放键和值**，非叶子节点是不存放数据的，只存放键

2. B+ Tree 结构

   ![B Tree(变种)](https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/B%20Tree(%E5%8F%98%E7%A7%8D).png)

### 2.6.8 哈希表

1. 使用哈希表来存取数据的性能是最高，O(1)，但不支持范围查找(区间访问)

## 3 InnoDB 和 MyISAM 区别

1. InnoDB 和 MyISAM 都是数据库表的引擎。那么在互联网公司，或者追求查询性能场景下，都会使用 InnoDB 作为表的存储引擎。
2. InnoDB 把索引和数据存放在一个文件中，通过找到索引就能直接在索引树上的叶子节点中获得完整的数据。 ==> 聚集索引
3. InnoDB 可以实现行锁/表锁。
4. MyISAM 把索引和数据存放在两个文件中，查找到索引后，还需要去另一个文件中找数据，性能会慢一些。 ==> 非聚集索引
5. MyISAM 天然支持表锁，而且支持全文索引。

## 4 索引常见面试题

1. **问题一：为什么非主键索引的叶子节点存放的数据是主键值**
   - **如果普通索引不存放主键，而存放完整数据。虽然提升了查询性能，但是导致数据冗余，造成空间浪费**
   - **如果普通索引不存放主键，而存放完整数据。对数据维护来说，更加复杂。因为一个地方修改数据，需要在多棵索引树上修改**

2. **问题二：为什么 InnoDB 表必须创建主键**

   - **如果没有主键，MySQL 优化器会给一个虚拟的主键，于是普通索引会使用这个虚拟主键–也会造成性能开销。**
   - **为了性能考虑，和设计初衷，那么创建表的时候就应该创建主键**

3. **问题三：为什么使用主键时推荐使用整型的自增主键**

   - **主键索引树上的非叶子节点键存放的是主键的值，而且数据的存放是有大小顺序的**
     - **整型: 大小顺序是很好比较的**
     - **字符串: 字符串的自然顺序的比较是要进行一次编码成为数值后再进行比较的**

   - **如果不使用自增，使用不规律的整数作为主键，那么主键索引树会使用更多的自旋次数来保证索引树叶子节点中的数据是从小到大-从左到右排列，因此性能必然比使用了自增主键的性能要差**


## 5 联合索引和最左前缀法则

1. **联合索引的特点: 使用一个索引来实现多个表中字段的索引效果**

2. 最左前缀法则是表示一条 sql 语句在联合索引中有没有走索引(命中索引/走全表扫描)

   ```SQL
   # 创建联合索引
   create index idx_a_b_c on table(a, b, c);
   
   # sql 语句有没有命中索引
   
   # 走联合索引
   select * from table1 where a = 10;
   # 走联合索引
   select * from table1 where a = 10 and b = 20;
   # 走联合索引
   select * from table1 where a = 10 and b = 20 and c = 30;
   # 不走联合索引
   select * from table1 where b = 10;
   # 不走联合索引
   select * from table1 where b = 10 and c = 30;
   # 走 a 索引
   select * from table1 where a = 10 and c = 30;
   # 不走联合索引
   select * from table1 where c = 30;
   # 走联合索引
   select * from table1 where a = 10 and c = 30 and b = 20; ==> 内部优化器
   ```


## 6 SQL 优化

1. SQL 优化的目的为了 SQL 语句能够具备优秀的查询性能，实现这样的目的有很多的途径：
   - 工程优化如何实现：数据库标准、表的结构标准、字段标准、创建索引
   - SQL 语句的优化：当前 SQL 语句有没有命中索引

### 6.1 工程优化如何实现

1. 基础规范

   - 表的存储引擎必须使用 InnoDB
   - 表字符集合默认使用 `utf8`，必要时候使用 `utf8mb4`
     - 通用，无乱码风险，汉字 3 字节，英文 1 字节
     - `utf8mb4` 是 `utf8` 的超集，有存储 4 字节例如表情符号时，使用它

   - 禁止使用存储过程，视图，触发器、Event

     - 对数据库性能影响比较大，互联网业务，能让站点层和服务层干的事情，不要交给数据库层

     - 调试，排错，迁移都比较困难，扩展性较差

   - 禁止在数据库中存储大文件，例如图片、可以将大文件存储在对象存储系统，数据库中存储路径
   - 禁止在线上环境做数据库压力测试
   - 测试，开发，线上数据库环境必须隔离

2. 命名规范

   - 库名、表名、列名必须使用小写，采用下划线分隔 tb_book t_book
     - abc，Abc，ABC 都是给自己埋坑
   - 库名，表名，列名必须见名知义，长度不要超过 32 字符
     - tmp、wushan 谁 TM 知道这些库是干嘛的
   - 库备份必须以 bak 为前缀，以日期为后缀
   - 从库必须以 `-s` 为后缀
   - 备库必须以 `-ss` 为后缀

3. 表设计规范

   - 单实例表的个数必须控制在 2000 个以内
   - 单表分表个数必须控制在 1024 个以内
   - 表必须以有主键，推荐使用 UNSIGNED 整数为主键
     - 删除无主键的表，如果是 row 模式的主从架构，从库会挂住
   - 禁止使用外键，如果要保证完整性，应由应用程序实现
     - 外键使得表之间相互耦合，影响 update/delete 等 SQL 性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈
   - **建议将大字段，访问频度低的字段拆分到单独表中存储，分离冷热数据**

4. 列设计规范
   - 根据业务区分使用 tinyint/int/bigint，分别会占用 1/4/8 字节
   - 根据业务区分使用 char/varchar
     - 字段长度固定，或者长度近似的业务场景，适合使用 char，能够减少碎片，查询性能
     - 字段长度相差较大，或者更新较少的业务场景，适合使用 varchar，能够减少空间
   - 根据业务区分使用 datetime/timestamp
     - 前者占用 5 个字节，后者占用 4 个字节，存储年使用 `YEAR`，存储日期使用 `DATE`，存储时间 `datetime`
   - 必须把字段定义为 NOT NULL 并设置默认值
     - NULL 的列使用索引，索引统计，值都更加复杂，MySQL 更难优化
     - NULL 需要更多的存储空间
     - NULL 只能采用 IS NULL 或者 IS NOT NULL，而在 `=/!=/in/not in` 时有大坑
   - 使用 `INT UNSIGNED` 存储 `IPv4` ，不要用 `char(15)`
     - 牵扯到国家代号，可能出现 `+/-/()` 等字符，例如 `+86`
     - 手机号不会用来做数学运算
     - `varchar` 可以做模糊查询，例如 `like '138%'`
   - 使用 TINYINY 来替代 ENUM
     - `Enum` 增加新值要进行 `DDL` 操作

5. 索引规范

   - 唯一索引使用 `uniq_[字段名]` 来命名
   - 非唯一索引使用 `idx_[字段名]` 来命名

   - 单张表索引数量建议控制在 5 个以内
     - 互联网高并发业务，太多索引会影响写性能
     - 生成执行计划时，如果索引太多，会降低性能，并可能导致 MySQL 选择不到最优索引
     - 异常复杂的查询需求，可以选择 `ES` 等更为合适的方式存储
   - 组合索引字段数不建议超过 5 个
     - 如果 5 个字段还不能极大缩小 row 范围，八成是设计有问题
   - 不建议在频繁更新的字段上建立索引
   - 非必要不要进行 `JOIN` 查询，如果要进行 `JOIN` 查询，被 `JOIN` 的字段必类型相同，并建立索引
     - 踩过因为 `JOIN` 字段类型不一致，而导致全表扫描的坑么
   - 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a, b, c)，相当于建立(a), (a, b), (a, b, c)

## 6.2 Explain 执行计划

1. 通过 Explain 工具可以对当前 SQL 语句的性能进行判断。
2. 在完成工程结构的优化之后，数据库、表、表中的字段及表的索引，都能支持海量数据的快速查询，但是查找依然需要通过 SQL 语句来实现，因此性能优秀的 SQL 语句是能够走索引，快速查找数据的。性能不 OK 的 SQL 语句，就不会走索引，导致全表扫描
3. 阿里云 rds 提供了慢 SQL 的查询功能。找到慢 SQL 后，如何做优化，以及如何查询一条 SQL 语句是否是慢 SQL，那就可以通过 Explain 工具。
4. 通过在 SQL 语句前面加上 Explain 关键字来执行，于是就能看出当前 SQL 语句的执行性能
5. 要想知道哪些 SQL 是慢 SQL，有两种方式：
   - 开启本地 MySQL 的慢查询日志
   - 阿里云提供的 RDS(第三方部署的 MySQL 服务)，提供了查询慢 SQL 的功能

6. 通过在 SQL 语句前面加上 explain 关键字，执行后并不会真正的执行 SQL 语句本身，而是通过 explain 工具来分析当前这条 SQL 的性能细节：比如是什么样的查询类型、可能用到的索引及实际用到的索引，和一些额外的信息

## 6.3 MySQL 的内部优化器

1. 在 SQL 查询开始之前，MySQL 内部优化器会进行一次自我优化，让这一次的查询性能尽可能的好

   ```SQL
   explain select * from tb_book where id = 1;
   
   show warnings;
   ```

2. 在执行上面这条 SQL 语句的时候，MySQL 内部优化器会把语句转换成下面这条 SQL，因为这样的性能更好(直接从索引里获取数据)

   ```SQL
   * select#1 */ select '1' AS `id`, '千锋 Java 厉害' AS `name` from `db_mysql_pro`.`tb_book` where true
   ```

## 6.4 Explain 各个列的细节

### 6.4.1 select_type 列

1. 该列描述了查询的类型:

   - **simple: 简单查询**
   - **primary: 外部的主查询**
   - **derived: 在 from 后面进行的字子查询，会产生衍生表**
   - **subquery: 在 form 的前面进行的子查询**
   - **union: 进行联合查询**

   

2. 来自简单的查询: simple 类型

   ```SQL
   explain select * from tb_book where id = 1;

3. 关闭对 MySQL 衍生表的合并优化

   ```SQL
   set session optimizer_switch = 'derived_merge=off';
   ```

4. 来自于复杂的查询：除 simple 之外的其他类型

   ```SQL
   EXPLAIN select (select 1 from tb_author where id = 1) from (select * from tb_book where id = 1) der；
   ```

   - `select * from tb_book where id = 1` 这一条执行的 sql 是 from 后面的子查询，该子查询只要在 from 后面，就会生成一张衍生表，因此它的查询类型为 **derived**
   - `select 1 from tb_author where id = 1` 这一条执行的 sql 是在 select 之后 from 之前的子查询，因此它的查询类型为 **subquery**
   - 最外部的 `select` 语句的查询类型是 **simple**

5. 对于 union 的联合查询，查询的类型是 union

   ```SQL
   explain select * from tb_book where id = 1 union select * from tb_book where id = 2;
   ```

### 6.4.2 table 列

1. 这一列表示该 sql 正在访问哪一张表。也可以看出正在访问的衍生表

### 6.4.3 type 列

1. 通过 type 列，可以直接的看出 SQL 语句的查询性能，性能从大到小的排列

   - 通过 Type 列，可以直接的看出 SQL 语句的查询性能，性能从大到小的排列

     ```
     null>system>const>er_ref>ref>range>index>ALL
     ```

   - 一般情况下我们要保证我们的 sql 类型的性能是 range 级别。不同的级别的情况:

     ```
     ```

     

