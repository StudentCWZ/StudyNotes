# 第二讲 索引

## 2-1 索引概述
1. 介绍
    - 索引(Index): 是帮助 MySQL 高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向数据)，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

2. 优缺点

    |                          **优势**                           |                           **劣势**                           |
    | :---------------------------------------------------------: | :----------------------------------------------------------: |
    |          提高数据检索的效率，较低数据库的 IO 成本           |                    索引列也是要占用空间的                    |
    | 通过索引列对数据进行排序，降低数据排序成本，降低 CPU 的消耗 | 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行 INSERT、UPDATE、DELETE 时，效率降低 |

## 2-2 索引结构

1. MySQL 的索引实在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：

    |    **索引结构**     |                           **描述**                           |
    | :-----------------: | :----------------------------------------------------------: |
    |   ==B+Tree 索引==   |      ==最常见的索引类型，大部分引擎都支持 B+ 树的索引==      |
    |      Hash 索引      | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |
    |  R-tree(空间索引)   | 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
    | Full-text(全文索引) | 是一种通过建立倒排索引，快速匹配文档的方式。类似 Lucene、Solr、ES |

2. 各引擎支持的索引结构

    |  **索引**   |    **InnoDB**    | **MyISAM** | **Memory** |
    | :---------: | :--------------: | :--------: | :--------: |
    | B+Tree 索引 |       支持       |    支持    |    支持    |
    |  Hash 索引  |      不支持      |   不支持   |    支持    |
    |  Hash 索引  |      不支持      |    支持    |   不支持   |
    |  Full-text  | 5.6 版本之后支持 |    支持    |   不支持   |

3. ==我们平常所说的索引，如果没有特别指明，都是指 B+ 树结构组织索引==

4. 二叉树图示

    - 基本图示

      <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="索引结构-二叉树" style="zoom: 50%;" />

    - 特殊图示

      <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%80%E5%8C%96%E6%88%90%E9%93%BE%E8%A1%A8.png" alt="索引结构-二叉树退化成链表" style="zoom:50%;" />

5. 二叉树缺点: 顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢。

6. 红黑树缺点: 大数据量情况下，层级较深，检索速度慢。 ==> (解决树的平衡问题)

7. B-Tree(多路平衡查找树): 
    - 以一颗最大度数(max-degree)为 5 (5 阶)的 B-Tree 为例子(每个节点最多存储 4 个 key，5 个指针)
    - 树的度数指的是一个节点的子节点个数

8. B+Tree
    - 以一棵最大度数(max-degree)为 4(4 阶)的 b+tree 为例子
    - 相对于 B-Tree 区别:
        - 所有的数据都会出现在叶子节点
        - 叶子节点形成一个单项链表

9. MySQL B+Tree
    - MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。

10. Hash
    - 哈希索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中
    - 如果两个(或多个)键值，映射到一个相同的槽位上，它们就产生了 hash 冲突(也称 hash 碰撞)，可以通过链表来解决(拉链法)
    - Hash 索引的特点
        - Hash 索引只能用于对等比较(=, in)，不支持范围查询(between, >, <, ...)
        - 无法利用索引完成排序操作
        - 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引
    - 在 MySQL 中，支持 hash 索引的是 Memory 引擎，而 InnoDB 中具有自适应 hash 功能，hash 索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的。

11. 思考题：为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？
     - 相对于二叉树，层级更少，搜索效率高；
     - 相对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着见撒后，要同样保存大量数据，只能增加树的高度，导致性能降低
     - 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作

## 2-3 索引分类

1. 相关索引分类如下：

   | **分类** |                       **含义**                       |         **特点**         | **关键字** |
   | :------: | :--------------------------------------------------: | :----------------------: | :--------: |
   | 主键索引 |                针对表中主键创建的索引                | 默认自动创建，只能有一个 |  PRIMRAY   |
   | 唯一索引 |           避免同一个表中某数据列中的值重复           |        可以有多个        |   UNIQUE   |
   | 常规索引 |                   快速定位特定数据                   |        可以有多个        |            |
   | 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 |        可以有多个        |  FULLTEXT  |

2. 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：聚集索引、二级索引

   |         **分类**          |                          **含义**                          |       **特点**       |
   | :-----------------------: | :--------------------------------------------------------: | :------------------: |
   | 聚集索引(Clustered Index) |   将数据存储与索引放一块，索引结构的叶子节点保存了行数据   | 必须有，而且只有一个 |
   | 二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 |     可以存在多个     |

3. 聚集索引选取规则

   - 如果存在主键，主键索引就是聚集索引

   - 如果不能存在主键，将使用第一个唯一索引(UNIQUE)作为聚集索引

   - 如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 row_id 作为隐藏的聚集索引

4. 思考题

   - 以下 SQL 语句，`select * from user where id = 10;` 和 `select * from user where name = 'Jack';` ，其中 id 为主键，name 字段为普通索引，哪个执行效率更高？
     - Answer
       - `select * from user where id = 10;` 执行效率高，因为相对于 `select * from user where name = 'Jack';` 来说，不涉及回表查询

   - InnoDB 主键索引的 B+Tree 高度为多高呢？
     - Answer
       - 假设：一行数据大小为 1 k，一页中可以存储 16 行这样的数据。 InnoDB 的指针占用 6 个字节的空间，主键即使为 bigint，占用的字节数为 8
       - 高度为 2: n * 8 + (n + 1) * 6 = 16 * 1024, 算出来 n 约为 1170； 1171 * 16 = 18736
       - 高度为 3: 1171 * 1171 * 16 = 21939856   

## 2-4 索引语法
1. 创建索引
    ```mysql
        CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name, ...);
    ```
2. 查看索引
    ```mysql
        SHOW INDEX FROM table_name;
    ```
3. 删除索引
    ```mysql
        DROP INDEX index_name ON table_name;
    ```

## 2-5 SQL 性能分析

## 2-6 索引使用

## 2-7 索引设计原则
