# 第四讲 视图、存储过程、触发器
## 4-1 视图

1. 视图(view)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且在使用视图时动态生成。

2. 通俗的讲，视图只保存了查询的 SQL 逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条 SQL 查询语句上

3. 创建视图

   ```SQL
   CREATE [OR REPLACE] VIEW 视图名称[(列表名称)] AS SELECT 语句 [WITH[CASCAD|LOCAL] CHECK OPTION]
   ```

4. 具体示例

   ```SQL
   create or replace view stu_v_1 as select id, name from student where id <= 10;
   ```

5. 查询

   ```SQL
   # 查看创建视图语句
   SHOW CREATE VIEW 视图名称;
   
   # 查看视图数据
   SELECT * FROM 视图名称 ...;
   ```

6. 具体示例

   ```SQL
   # 查看创建视图
   show create view stu_v_1;
   
   # 查看视图数据
   select * from stu_v_1;
   select * from stu_v_1 where id < 3;
   ```

7. 修改视图

   ```SQL
   # 方式一
   CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT 语句 [WITH[CASCADED|LOCAL] CHECK OPTION]
   
   # 方式二
   ALTER VIEW 视图名称[(列名列表)] AS SELECT 语句 [WITH[CASCADED|LOCAL] CHECK OPTION]
   ```

8. 具体示例

   ```SQL
   # 方式一
   create or replace view stu_v_1 as select id, name, no from student where id <= 10;
   
   # 方式二(再次修改回来)
   alter view stu_v_1 as select id, name from student where id <= 10;
   ```

9. 删除

   ```SQL
   DROP VIEW [IF EXISTS 视图名称 [视图名称] ...
   ```

10. 具体示例

    ```SQL
    drop view if exists stu_v_1;
    ```

### 4-1-1 视图的检查选项

1. 当使用 WITH CHECK OPTION 子句创建视图时，MySQL 会通过视图检查正在更改的每个行，例如插入、更新、删除，以使其符合视图的定义。
2. MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查范围，MySQL 提供了两个选项：CASCAD 和 LOCAL，默认值为 CASCADED。

3. `CASCADED` 具体示例

   ```SQL
   # 创建视图
   create view stu_v_1 as select id, name from student where id <= 20; 
   
   # 插入成功
   insert into stu_v_1 values(5, "Tom");
   
   # 插入成功
   insert into stu_v_1 values(25, "Tom");
   
   # 这相当于给上述第一条语句后面也加上了 with cascaded check option 
   create view stu_v_2 as select id, name from stu_v_1 where id >= 10 with cascaded check option;
   
   # 插入失败
   insert into stu_v_2 values(7, "Tom");
   
   # 插入失败
   insert into stu_v_2 values(26, "Tom");
   
   # 插入成功
   insert into stu_v_2 values(15, "Tom");
   
   # 创建视图
   create view stu_v_3 as select id, name from stu_v_2 where id <= 15;
   
   # 插入成功
   insert into stu_v_3 values(11, "Tom");
   
   # 插入成功
   insert into stu_v_3 values(17, "Tom");
   
   # 插入失败
   insert into stu_v_3 values(28, "Tom");
   ```

4. `LOCAL` 具体示例

   ```SQL
   # 创建视图
   create view stu_v_4 as select id, name from student where id <= 15; 
   
   # 插入成功
   insert into stu_v_4 values(5, "Tom");
   
   # 插入成功
   insert into stu_v_4 values(16, "Tom");
   
   # 这并没有给上述第一条语句后加上了 with local check option 
   create view stu_v_5 as select id, name from stu_v_4 where id >= 10 with local check option;
   
   # 插入成功
   insert into stu_v_5 values(13, "Tom");
   
   # 插入成功
   insert into stu_v_5 values(17, "Tom");
   
   # 创建视图
   create view stu_v_6 as select id, name from stu_v_5 where id < 20; 
   
   # 插入成功
   insert into stu_v_6 values(14, "Tom");
   ```

### 4-1-2 视图的更新及作用

1. 要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：

   - **聚合函数或窗口函数(sum()、min()、Max()、COUNT())**
   - **DISTINCT**
   - **GROUP BY**
   - **HAVING**
   - **UNION 或者 UNION ALL**

2.  具体示例

   ```SQL
   # 创建视图
   create view stu_v_count as select count(*) from student;
   
   # 插入失败
   insert into stu_v_count values(10);
   ```

3. **视图的作用**

   - **简单**
     - **视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次限定全部条件****
   - **安全**
     - **数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据****

   - **数据独立**
     - **视图可以帮助用户屏蔽真实表结构变化带来的影响**

### 4.1.3 具体案例

1. 为了保证数据表的安全性，开发人员在操作 tb_user 表时，只能看到的用户的基本字段，屏蔽手机和邮箱两个字段

   ```SQL
   # 创建视图
   create view tb_user_view as select id, name, profession, age, gender, status, create_time from tb_user;
   
   # 查询所有用户(屏蔽手机和邮箱两个字段)
   select * from tb_user_view;
   
   ```

2. 查询每个学生所选修的课程(三张表联查)，这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图

   ```SQL
   # 三张表联查
   select * from student s, student_course sc, course c where s.id = sc.studentid and sc.courseid = c.id;
   
   # 三张表联查
   select s.name, s.no, c.name from student s, student_course sc, course c where s.id = sc.studentid and sc.courseid = c.id;
   
   # 创建视图
   create view tb_stu_course_view as select s.name student_name, s.no student_no, c.name course_name from student s, student_course sc, course c where s.id = sc.studentid and sc.courseid = c.id;
   
   # 查询视图
   select * from tb_stu_course_view;

