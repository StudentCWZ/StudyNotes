# 第四讲 视图、存储过程、触发器
## 4.1 视图

1. 视图(view)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且在使用视图时动态生成。

2. 通俗的讲，视图只保存了查询的 SQL 逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条 SQL 查询语句上

3. 创建视图

   ```SQL
   CREATE [OR REPLACE] VIEW 视图名称[(列表名称)] AS SELECT 语句 [WITH[CASCAD|LOCAL] CHECK OPTION]
   ```

4. 具体示例

   ```SQL
   create or replace view stu_v_1 as select id, name from student where id <= 10;
   ```

5. 查询

   ```SQL
   # 查看创建视图语句
   SHOW CREATE VIEW 视图名称;
   
   # 查看视图数据
   SELECT * FROM 视图名称 ...;
   ```

6. 具体示例

   ```SQL
   # 查看创建视图
   show create view stu_v_1;
   
   # 查看视图数据
   select * from stu_v_1;
   select * from stu_v_1 where id < 3;
   ```

7. 修改视图

   ```SQL
   # 方式一
   CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT 语句 [WITH[CASCADED|LOCAL] CHECK OPTION]
   
   # 方式二
   ALTER VIEW 视图名称[(列名列表)] AS SELECT 语句 [WITH[CASCADED|LOCAL] CHECK OPTION]
   ```

8. 具体示例

   ```SQL
   # 方式一
   create or replace view stu_v_1 as select id, name, no from student where id <= 10;
   
   # 方式二(再次修改回来)
   alter view stu_v_1 as select id, name from student where id <= 10;
   ```

9. 删除

   ```SQL
   DROP VIEW [IF EXISTS 视图名称 [视图名称] ...
   ```

10. 具体示例

    ```SQL
    drop view if exists stu_v_1;
    ```

### 4.1.1 视图的检查选项

1. 当使用 WITH CHECK OPTION 子句创建视图时，MySQL 会通过视图检查正在更改的每个行，例如插入、更新、删除，以使其符合视图的定义。
2. MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查范围，MySQL 提供了两个选项：CASCAD 和 LOCAL，默认值为 CASCADED。

3. `CASCADED` 具体示例

   ```SQL
   # 创建视图
   create view stu_v_1 as select id, name from student where id <= 20; 
   
   # 插入成功
   insert into stu_v_1 values(5, "Tom");
   
   # 插入成功
   insert into stu_v_1 values(25, "Tom");
   
   # 这相当于给上述第一条语句后面也加上了 with cascaded check option 
   create view stu_v_2 as select id, name from stu_v_1 where id >= 10 with cascaded check option;
   
   # 插入失败
   insert into stu_v_2 values(7, "Tom");
   
   # 插入失败
   insert into stu_v_2 values(26, "Tom");
   
   # 插入成功
   insert into stu_v_2 values(15, "Tom");
   
   # 创建视图
   create view stu_v_3 as select id, name from stu_v_2 where id <= 15;
   
   # 插入成功
   insert into stu_v_3 values(11, "Tom");
   
   # 插入成功
   insert into stu_v_3 values(17, "Tom");
   
   # 插入失败
   insert into stu_v_3 values(28, "Tom");
   ```

4. `LOCAL` 具体示例

   ```SQL
   # 创建视图
   create view stu_v_4 as select id, name from student where id <= 15; 
   
   # 插入成功
   insert into stu_v_4 values(5, "Tom");
   
   # 插入成功
   insert into stu_v_4 values(16, "Tom");
   
   # 这并没有给上述第一条语句后加上了 with local check option 
   create view stu_v_5 as select id, name from stu_v_4 where id >= 10 with local check option;
   
   # 插入成功
   insert into stu_v_5 values(13, "Tom");
   
   # 插入成功
   insert into stu_v_5 values(17, "Tom");
   
   # 创建视图
   create view stu_v_6 as select id, name from stu_v_5 where id < 20; 
   
   # 插入成功
   insert into stu_v_6 values(14, "Tom");
   ```

### 4.1.2 视图的更新及作用

1. 要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：

   - **聚合函数或窗口函数(sum()、min()、Max()、COUNT())**
   - **DISTINCT**
   - **GROUP BY**
   - **HAVING**
   - **UNION 或者 UNION ALL**

2.  具体示例

   ```SQL
   # 创建视图
   create view stu_v_count as select count(*) from student;
   
   # 插入失败
   insert into stu_v_count values(10);
   ```

3. **视图的作用**

   - **简单**
     - **视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次限定全部条件****
   - **安全**
     - **数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据****

   - **数据独立**
     - **视图可以帮助用户屏蔽真实表结构变化带来的影响**

### 4.1.3 具体案例

1. 为了保证数据表的安全性，开发人员在操作 tb_user 表时，只能看到的用户的基本字段，屏蔽手机和邮箱两个字段

   ```SQL
   # 创建视图
   create view tb_user_view as select id, name, profession, age, gender, status, create_time from tb_user;
   
   # 查询所有用户(屏蔽手机和邮箱两个字段)
   select * from tb_user_view;
   
   ```

2. 查询每个学生所选修的课程(三张表联查)，这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图

   ```SQL
   # 三张表联查
   select * from student s, student_course sc, course c where s.id = sc.studentid and sc.courseid = c.id;
   
   # 三张表联查
   select s.name, s.no, c.name from student s, student_course sc, course c where s.id = sc.studentid and sc.courseid = c.id;
   
   # 创建视图
   create view tb_stu_course_view as select s.name student_name, s.no student_no, c.name course_name from student s, student_course sc, course c where s.id = sc.studentid and sc.courseid = c.id;
   
   # 查询视图
   select * from tb_stu_course_view;

## 4.2 存储过程

### 4.2.1 介绍

1. 存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好吃的
2. 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用
3. 存储过程的特点
   - **封装，复用**
   - **可以接收参数，也可以返回数据**
   - **减少网络交互，效率提升**

### 4.2.2 基本语法

1. **创建****

   ```SQL
   CREATE PROCEDURE 存储过程([参数列表])
   BEGIN
   	-- SQL 语句
   END;
   ```
   
2. 调用

   ```SQL
   CALL 名称 ([参数])
   ```

3. 具体示例

   - 创建

     ```SQL
     create procedure p1()
     begin
     	select count(*) from student;
     end;
     ```

   - 调用

     ```SQL
     call p1();
     ```

4. **查看**

   ```SQL
   # 查询指定数据库的存储过程及状态信息
   SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xxx';
   
   # 查询某个存储过程的定义
   SHOW CREATE PROCEDURE 存储过程名称;
   ```

5. 具体示例

   ```SQL
   # 查询指定数据库的存储过程及状态信息
   select * from information_schema.ROUTINES where POUTINE_SCHEMA = 'itcast';
   
   # 查询某个存储过程的定义
   show create procedure p1;
   ```

6. **删除**

   ```SQL
   DROP PROCEDURE [IF EXISTS] 存储过程名称;
   ```

7. 具体示例

   ```SQL
   drop procedure if exists p1();
   ```

8. 注意：在命令行中，执行创建存储过程的 SQL 时需要通过冠军爱着你 delimiter 指定 SQL 语句的结束符

   ```SQL
   create procedure p1()
   begin
   	select count(*) from student;
   end$$
   ```

### 4.2.3 变量

1. **系统变量**是 MySQL 服务器提供的，不是用户定义的，属于服务器层面。分为**全局变量**(GLOBAL)、**会话变量(SESSION)**。

2. 查看系统变量

   - 语法

     ```SQL
     # 查看所有系统变量
     SHOW [SESSION|GLOBAL] VARIABLES;
     
     # 可以通过 like 模糊匹配方式查找变量
     SHOW [SESSION|GLOBAL] VARIABLES LIKE '....';
     
     # 查看指定变量的值
     SHOW @@[SESSION|GLOBAL] 系统变量名;
     ```

   - 具体示例

     ```SQL
     # 查看所有系统变量
     # 没加级别就是 session 级别
     show variables;
     
     # 可以通过 like 模糊匹配方式查找变量、
     show session variables like 'auto%';
     show global variables like 'auto%';
     
     # 查看指定变量的值
     select @@session.autocommit;
     ```

3. 设置系统变量

   - 语法

     ```SQL
     # 设置系统变量
     SET [SESSION|GLOBAL] 系统变量名=值;
     
     # 设置系统变量
     SET @@[SESSION|GLOBAL] 系统变量名=值;
     ```

   - 具体示例

     ```SQL
     # 设置系统变量
     set session autocommit = 0;
     
     # 设置系统变量
     set @@session.autocommit = 0;
     ```

4. 注意事项
   - **如果没有指定 SESSION/GLOBAL，默认是 SESSION，会话变量**
   - **MySQL 服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置**

5. **用户定义变量**是用户根据需要自己定义的变量，用户变量不再提前说明，在用的时候直接用 "@变量名" 使用就可以。其作用域为当前连接。

6. **用户定义变量语法**

   - 赋值

     ```SQL
     SET @var_name=expr [, @var_name=expr] ...;
     SET @var_name:=expr [, @var_name:=expr] ...;
     SELECT @var_name := expr [,@var_name:=expr] ...;
     SELECT 字段名 INTO @var_name FROM 表名;
     ```

   - 使用

     ```SQL
     SELECT @var_name;
     ```

   - 具体示例

     ```SQL
     set @myname = 'itcast';
     set @myage := 10;
     set @mygender := '男', @myhobby := 'Java';
     select @mycolor := 'red';
     select count(*) into @mycount from tb_user;
     # 使用
     select @myname, @myage, @mygender, @myhobby;
     ```

7. **注意**

   - **用户定义的变量无需对其进行声明或初始化，只不过获取到的值为 NULL**

8. **局部变量**是根据需要定义的在局部生效的变量，在访问之前，需要 DECLARE 声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内部声明的 `BEGIN ... END `块

9. 声明

   ```SQL
   DECLARE 变量名 变量类型[DEFAULT ...]
   ```

10. 变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME 等

11. 赋值

    ```SQL
    SET 变量名=值;
    SET 变量名:=值;
    SELECT 字段名 INTO 变量名 FROM 表名...;
    ```

12. 具体示例

    ```SQL
    create procedure p2()
    begin
    	declare stu_count int default;
    	set stu_count := 100;
    	select count(*) into stu_count from student;
    end;
    ```



