# 第五讲 锁

## 5.1 概述

1. 介绍
   - 锁是计算机协调多个进程或线程并发访问某一资源的机制，在数据库中，除传统的计算资源(cpu、RAM、I/O)的争用外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响并发访问性能的一个重要因素。从这个角度说，锁对数据库而言显得尤其重要，也更加复杂。
2. 分类
   - **全局锁: 锁定数据库中的所有表**
   - **表级锁: 每次操作锁住整张表**
   - **行级锁: 每次操作锁住的行数据**

## 5.2 全局锁

1. 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞。

2. 其典型的使用场景是做全库表进行锁定，从而获取一致性视图，保证数据的完整性。

3. 分析：如果进行全库备份不加锁，会导致数据不一致。(**回答 ==> 角度**)

4. **加全局锁**

   ```SQL
   flush tables with read lock;
   ```

5. **数据备份**

   ```bash
   mysqldump -uroot -p1234 itcast > itcast.sql;
   ```

6. **全局锁的释放**

   ```SQL
   unlock tables;
   ```

7. 数据库中加全局锁，是一个比较重的操作，存在以下问题：

   - 如果从主库上备份，那么备份期间都不能执行更新，业务基本上就得停摆
   - 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟

8. 在 InnoDB 引擎中，我们可以在备份时加上参数 `--single-transaction` 参数来完成不加锁的一致性数据备份

   ```bash
   mysqldump --single-transaction -uroot -p1234 itcast > itcast.sql;
   ```

## 5.3 表级锁

1. 介绍

   - 表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在 MyISAM、InnoDB、BDB 等存储引擎中。

2. 对于表级锁，主要分为以下三类：

   - **表锁**
   - **原数据锁**(meta data lock, MDL)
   - **意向锁**

3. 表锁

   - 对于表锁，分为两类：
     - 表共享锁(read lock)
     - 表独占写锁(write lock)

4. 语法

   - **加锁**

     ```SQL
     -- 加锁
     lock tables 表名... read/write
     ```

   - **释放锁**

     ```SQL
     unlock tables / 客户端断开连接
     ```

## 5.4 行级锁